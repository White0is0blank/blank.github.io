---
date : 2024-7-9 10:00:00
title: Hello World
update: 2024-7-9 10:00:00
tags: [算法,C++]
categories: [和算法斗志斗勇的日子]
swiper_index: 1 #置顶轮播图顺序，非负整数，数字越大越靠前
---
# 数组

### 二分查找

在有序的数组中进行查找

###### **LeetCode-704二分查找**

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        while(left <= right){
            int mid = (left + right)/2;//求中间的位置
            if(nums[mid] > target){
                right = mid - 1;
            }else if(nums[mid] < target){
                left = mid + 1;
            }else{
                return mid;
            }
        }
        return -1;
    }
};
```

时间复杂度：O(logn)

<img src="https://raw.githubusercontent.com/WhiteIsBlank/Image/main/20240706011507.png" style="zoom:67%;" />

[如何正确推导二分查找的时间复杂度？为啥是 O(logn)?](https://www.bilibili.com/video/BV1aw411A7uL?vd_source=0594117fb42cd21e3bfb0166f3dfae8b)

### 移除元素

###### **LeetCode-27移除元素**

双指针fast和slow，当nums[fast] != target，才把值赋给slow这个指针位置

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int fast,slow;
        fast = slow = 0;
        for(;fast < nums.size();fast++){
            if(nums[fast] != val){
                nums[slow++] = nums[fast];
                //nums[slow] = nums[fast];
                //slow++;
            }
        }
        return slow;//为什么不加1，一般长度都是索引+1，因为在最后一次赋值后slow自增
    }
};
```

时间复杂度：O(n)

###### **LeetCode-26删除有序数组中的重复项**

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int fast,slow,flag,k;
        fast = slow = flag = 0;
        k = nums.size();
        for(;flag < nums.size() && flag < k;flag++){
            slow = fast = flag + 1;
            for(;fast < nums.size() && fast < k;fast++){
                if(nums[fast] != nums[flag]){
                    nums[slow++] = nums[fast];
                }
            }
            k = slow;
        }
        return k;
    }
};
```

时间复杂度：O(n^2)

由于了解到是有序的一个数组，所以进行修正

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int fast,slow;
        fast = slow = 0;
        for(fast++;fast < nums.size();fast++){
            if(nums[fast] != nums[slow]){
                slow++;
                nums[slow] = nums[fast];
            }
        }
        return slow+1;
     }
};
```

![](https://raw.githubusercontent.com/WhiteIsBlank/Image/main/20240707145918.png)

时间复杂度：O(n)

### 有序数组的平方

###### **LeetCode-977有序数组的平方和**

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int k = nums.size() - 1;//从两头开始所以k从最后一个位置开始
        vector<int> res(nums.size());
        for(int i = 0,j = k;i <= j;){
            if(nums[i]*nums[i] > nums[j]*nums[j]){
                res[k--] = nums[i]*nums[i];
                i++;
            }else{
                res[k--] = nums[j]*nums[j];
                j--;
            }
        }
        return res;
    }
};
```

![](https://raw.githubusercontent.com/WhiteIsBlank/Image/main/20240707152313.png)

时间复杂度：O(n)

###### LeetCode-88合并两个有序数组

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int i,j,k;
        i = j = k = 0;
        vector<int> res(m+n);
        for(;i < m && j < n && n*m > 0;){
            if(nums1[i] < nums2[j]){
                res[k++] = nums1[i++];   
            }else{
                res[k++] = nums2[j++];
            }
        }
        if(i < m){
            for(;i < m;i++){
                res[k++] = nums1[i];
            }
        }
        if(j < n){
            for(;j < n;j++){
                res[k++] = nums2[j];
            }
        }
        nums1 = res;
    }
};
```

![](https://raw.githubusercontent.com/WhiteIsBlank/Image/main/20240707160753.png)
